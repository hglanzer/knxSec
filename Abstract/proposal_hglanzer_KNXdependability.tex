\documentclass[a4paper,12pt,twoside]{memoir}

\usepackage{TUINFDA}

\thesistitle{Proposal}
%\thesissubtitle{KNX For Safety Critical Environments} % optional
\thesissubtitle{Highly available KNX networks}
\thesisdate{25.8.2014}

% all titles and designations have to be gender-related!
\thesisdegree{Diplom-Ingenieurin}{Diplom-Ingenieurin}
\thesiscurriculum{Technische Inforumatik}{Computer Engineering} % your study
\thesisverfassung{Verfasserin} % Verfasser
\thesisauthor{Harald Glanzer} % your name
\thesisauthoraddress{Hardtgasse 25/12A, 1190 Wien} % your address
\thesismatrikelno{0727156} % your registration number

\thesisbetreins{Ao.Univ.Prof.Dr. Wolfgang Kastner}
\thesisbetrzwei{Dipl. Ing. Lukas Krammer}

% define page numbering styles
\makepagestyle{numberCorner}


%\makeevenfoot{numberCorner}{\thepage}{}{}
%\makeevenfoot{numberCorner}{}{}{\thepage}
%\makeoddfoot{numberCorner}{}{}{\thepage}

% define custom macros for specific formats or names
\newcommand{\uml}[1]{\texttt{#1}}
\newcommand{\cd}{\textsf{Class Diagram}}

\usepackage[backend=bibtex]{biblatex}
\addbibresource{references.bib}


%\RequirePackage[backend=bibtex]{biblatex}

\begin{document}

\captionnamefont{\bfseries}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%   FRONTMATTER    %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frontmatter
\pagenumbering{normal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%   TITLEPAGES    %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% an english translation may follow
\include{titlepage_en} % optional


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%   ABSTARCT    %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Problem statement}

KNX is an open communications protocol for building automation.
It uses a layered structure and supports wired communication over twisted pair
and power line as well wireless communication by radio or infrared transmission. 
Additionally, it defines gateways to the TCP/IP world. 
As such, it can be used for controlling traditional services like heating, ventilation and air conditioning(HVAC), but also for more
sophisticated applications \cite{knxapps}
like surveillance or fire alarm systems of buildings.
\\
Given these potential applications, such a communications protocol can constitute a potential vulnerable point an adversary
could exploit if there are no countermeasures deployed.
Possible attacks range from DOS attacks by simply physically shortcutting a line
connection to replay attacks or eavesdropping, interception, altering and injecting of arbitrary telegrams.
The countermeasure providing integrity, confidentiality and authenticity consists of authentication
between the sender and receiver of a message, and encryption of these messages, combined in a security scheme
called 'Authenticated Encryption'.
\\
\\
Encryption uses block or stream ciphers to garble the cleartext message into a block respectively stream
of pseudo-random binary zeros and ones. Without possessing the key, the encryption must not
be reversible in feasible time to protect the secret message from unauthorized entities.
\\
\\
Authenticity, on the other side, takes blocks of input data and produces a short (compared
to the data itself, which can consist of an arbitrarily large number of blocks) 'message authentication code' or MAC
for this data, which will be sent along with the data. The MAC function is some kind
of one-way-function and it must be 'difficult' to reverse the process, i.e. find parts or the whole block 
which was feed to the function to obtain the given MAC.
This way, tampering of the sent data can be
detected and the corresponding datagram will be discarded if the message was altered. Analog to encryption,
it must be infeasible to find other MACs for the same message.   
\\
Availability, in general, can only be achieved by redundancy, by using replicated resources. Therefore, all
resources needed for transmitting data between two points must exist redundantly and independently from 
each other.
\\
\\
This work's overall topic is to build a gateway for KNX which improves security and availability, allowing 
to use KNX in a security-critical environment. As will be shown, the security concept defined in the
actual KNX Standard must be regarded as insufficient because the standard simply doesn't provide any encryption 
or authentication\cite{knxSpec}. 


\section{Expected results}

The final goal of this work is to build a prototype of a secure and high-available KNX network. This network
will consist of raspberry pi single board computers, each connected to the secure part of the KNX network
with 2 KNX-USB-dongles. Additionally, each raspberry pi is connected by
another USB dongle to another KNX  network in the standard, unsecured way. Therefore, the rasperry pi's
are gateways between a secure and an insecure KNX network, each of them running a master daemon responsible
for reading datagrams from the KNX insecure world, encrypting them and sending them over the secure
KNX lines. On the counterparts, the message will be decrypted, checked for integrity and sent
on its further way if the message is found to be untampered. 
\\
While it is not obvious that confidentiality cannot be achieved without authenticity,
it will be shown that booth concepts must go hand in hand to achieve confidentiality. 
Consequently, the security layer will use strong encryption \textit{and} authentication to guard
against attacks.
\\

%To gain availability, a handshake protocol will be used, as well as some kind of 'heartbeat' mechanism to
%detect outages of one communication line as soon as possible, allowing to switch to the replicated line 
%instantaneously
For gaining availability, it would be possible to define some kind of 'heartbeat' protocol which checks the status
of the 2 lines, and switches the line in case of a failure. A disadvantage of this approach is that a considerable
amount of bus load is generated. Alternatively, it is possible to just copy every KNX message to booth lines
(after encrypting it), and use some kind of counter to remove duplicates on the receiving side. This solution
needs no additional traffic, and is also 'faster' because no fail over recognition time is needed. 
\\

%While it would be possible to encrypt and authenticate only the actual payloads, and leave the status
%datagrams unencrypted, a cleaner and more elegant solution is to encrypt and authenticate booth message 
%types. This makes it possible to use the concept of \textit{divide et impera} in an uncompromising way.
%Additionally, attacks against the heartbeat - mechanism become impossible.

Because a  major concern of this work is, given the low
bandwidth of KNX TP, to keep the introduced overhead as small as possible, the latter solution is preferred. It is important to note that the practical part of this work will only
handle the twisted-pair media of KNX, although the basic principles can be deployed in a modified manner in
wireless and power-line networks as well. 

After the master daemon has been implemented, a threat analysis will be conducted to proof that the system can withstand the defined attacks and is robust,
i.e. that it can recover from erroneus states. This will be done by building a small test setup, consisting of at least 2 security gateways and various
KNX hardware, that will be exposed to the various defined attacks.

\section{Methodological approach}

The methodological approach will follow the typical ordering, namely research, concept, implementation and 
evaluation / critical reflection:
\\

Every secure system will just work within some defined barriers - it is impossible to build a system that
is secure under all circumstances. So, the very first step will be to define a realistic
thread scenario. 
Ensuring security in a network is a complex and comprehensive topic, fortunately, canonical ways how to employ authenticated
encryption exists, therefore the next step is to decide which ciphers should be used, how the keys will
be  distributed and what kind of MAC to use. Additionally, a reasonable concept has to be found
to guarantee high availability without introducing too much overhead.
After it has been examined what kind of crypto-primitives will be used, the basic structure 
of the security layer must be defined. This layer should be as transparent as possible to
allow it's re-use in different environments, i.e. different transport media. 
On top of the security layer, the methods to achieve availability have to be defined.
As basis for implementation of a real-world testing environment, rasperry pi's will be used.
These are small but powerful single board computers, based on ARM processors, 
using a Linux kernel as operating system. A C++ KNX API named 'eibd' exists and will be used
for the KNX/USB interface. So, the resulting daemon will consist of a stack composed of EIBD,
the security / key exchange layer in combination with a cryptographic library and the availability layer.

After implementation, it must be shown that this construction indeed withstands the defined attacks,
and that the protocol works in practice.
 

\section{Structure of the work}
\begin{enumerate}
  \item Introduction
  \item KNX
  \begin{itemize}
    \item Specification
    \item Overview of the defined layers
    \item Attacks on KNX
  \end{itemize}
 
  \item State of the art
      \begin{itemize}
  
  \item Computer Security
  \begin{itemize}
    \item Definition of Security
    \item Types of Attacks
    \item Basic Concepts of Number Theory used(Fermat, Euler)
    \item Basic Concepts of Probability Theory used
    \item Encryption Schemes
    \item Authentication Schemes
    \item Authenticated Encryption
    \item Distribution of Keys
    \item Symmetric vs. Asymmetric Encryption
    \item Random Number Generators
  \end{itemize}

  \item Availability
  \begin{itemize}
    \item Requirements for Availability
    \item Protocol Used
    \item Resynchronization
  \end{itemize}
    \end{itemize}

  \item Security Concept
  \begin{itemize}
    \item Key Generation and Distribution
    \item Definition of the Status Messages
    \item Definition of the MAC
    \item Definition of the Cipher
    \item Definition of the Tunneling Mode
    
    \item Evaluation
  \begin{itemize}
    \item Implemenation 
    \item Performance
    \item Threat analysis
  \end{itemize}
  \end{itemize}
  
  
 
  \item Critical Reflections

\end{enumerate}
  
\section{State of the art}

As stated earlier, KNX defines no methods for securing datagrams in the original proposal.
On the other hand, some proposals which promise to fix this issue exist, nevertheless these projects didn't
make it further than any theoretical level:

\begin{itemize}
 \item {eibsec}\cite{WG2006d} defines a security extension to KNX which uses AES encryption and dedicated key
servers
 \item Salvatore Cavalieri and Giovanni Cutuli\cite{knxsec} propose another way how to authenticate and
 encrypt KNX traffic.
\end{itemize}

While these 2 approaches try to bring confidentiality to KNX, this work will also add availability to KNX, as stated 
above. Additionally, this work will not rely on key servers, thus eliminating the need for a single 'point of trust'.
%Last but not least, the work of Salvatore Cavalieri and Giovanni Cutuli contains a serious design flaw by delegating 
%the task of key generation to a so called 'controller' with a fixed KNX address, which will be used to negotiate a key,
%thus using the KNX address as authentication property. If it is possible to deploy a malicious knx device into the network
%which responds 'faster' than the controller, the whole architecture is rendered useless. \cite{knxsecExt} by these authors
%addresses this shortcoming, but again, just makes theoretical assumptions.
\\
In contrast to these proposals, this work will provide a real-world implementation, by using a tunneling method, similar to tunnel mode implemented by IPsec \cite{rfc4301}.
IPsec, an extension to IP, can authenticate and encrypt data sent with IP by defining two security services,
namely the 'Authentication Header' to provide authenticity, and the 'Encapsulating Security Payload' for confidentiality. IKE, Internet
Key Exchange, is used as key negotiating protocol. This way,
IPsec can provide end-to-end encryption and protect the payload of higher level protocols like TCP or UDP. 
\\
Instead of self-implementing the needed crypto-primitives, the use of an API like 'crypto++' or 'Keyczar'
is favored because these libraries are widely used, open source, maintained and have proven to be secure
in the field. These libraries implement a wide range of authentication, encryption and key exchange modes, thus
providing great flexibility. Therefore, some basic design decisions have to be made.

 A fundamental property is the data format, i.e. if the data is to be handled in form of blocks or in form of a continuous
 data stream. Stream ciphers can be provable 'perfect secret' in principle
 and can be implemented as simple as bitwise xor'ing of key and data(i.e. the one-time pad). 
 
 Block ciphers come in 2 flavors: pseudo-random functions(PRF), and pseudo-random permutations(PRP). While the latter one is reversible,
 this is not true for the first one. Therefor, PRFs can only be used in constructions which do not depend on a reverse function, for
 example like 'Feistel Networks'. A widely used encryption standard is 'AES', the advanced encryption standard, derived from a block cipher
 called 'Rijndel'.
 This construction is reversible(i.e. is a PRP) and is also called a 'substitution-permutation-network', named after it's 2 basic building blocks.
 
 Another important distinguishing point is the mode of operation: this basically means which construct is used to transform cleartext data
 into the needed pseudo-random representation, which underlying cipher is used, and also defines how this transformation is reversed for decryption.
 There are modes for encryption and authentication, some modes can also be used for booth tasks(i.e. cipher block chaining, CBC). 
 
 Additionally, this property decides what
 is done first: encryption, and afterwards authentication of the encrypted data, or authentication of the cleartext data,
 appending the obtained MAC to the cleartext data, and encrypting data and MAC afterwards. Depending on this ordering and
 what modes are used for authentication and encryption, this option may enable attacks like 'padding oracles'\cite{Vaudenay02securityflaws}. Another possibility
 is to generate a MAC for the cleartext data, and only encrypt the data itself. Obviously, care must be taken that the MAC does not
 carry any information about the cleartext data.
 
 Another very fundamental difference is which kind of keys are used, i.e. symmetric vs. asymmetric encryption: while symmetric encryption is superior in
 regards of performance, symmetric keys need an already established, secure channel for key exchange. Because of
 that, a mixture of booth modes is used in prominent protocols(i.e. SSL\cite{rfc2246}).
 The key exchange algorithm defines how the keys get distributed to all devices which are part of the secure network.
 It would be possible to fix a key, place this key on all devices and use this 'pre-shared secret' for symmetric
 encryption, but this key cannot be changed at a later point without direct interaction on all devices. A better way is to use some
 kind of asymmetric key which is used to establish session keys, which can be used in a symmetric manner. Well known examples
 of asymmetric or public key algorithms are 'RSA'\cite{Rivest:1978:MOD:359340.359342} and 'Diffie-Helmann'\cite{1055638}. While the latter one was originally based on exponentiation,
 a new method based on elliptic curves has been found which can achieve the same level of security with shorter keys.
 Depending on the mode of operation and the length of the used keys, there exists an upper bound on
 how many messages can be sent securely without changing the key. Therefore, it must be either made sure that this number 
 cannot be achieved in a reasonable time, or some kind of key-renegotiation has to be used, which is the task of the key management algorithm.
 Nevertheless, if a session key and the corresponding traffic gets known to an adversary, all the past data will be disclosed(and all future traffic
 if no new key is used). Protocols like 'off the record messaging', OTR\cite{Borisov:2004:OCW:1029179.1029200}, avoid this problem by using short term session keys, and thus providing
 'perfect forward secrecy'. This property ensures that, even if a key is known to an adversary, no future and no past messages can be decrypted(beside of
 one single message). Problematic about OTR is its lack of support for multi-party conversations, a feature that is tried to be achieved with multi-party OTR
 (mpOTR)\cite{Goldberg:2009:MOM:1653662.1653705,}\cite{Liu:2013:IGO:2517840.2517867}.
 
 Finally, a critical prerequisite is the used pseudo random number generator('PRNG').
 While the used platform contains a hardware based PRNG, is has to be examined if the provided entropy can be considered
 secure, because a predictable PRNG turns all other cryptographic measurements useless.
 
 
\section{Relatedness to Computer Engineering}

Modern cryptography relies heavily on number theory and probabilistic theory and is the basis of this work.
The practical work will be to implement the multi-threaded daemons on the raspberry pi's, written in the low-level programming language
C, by using the help of the C++ API 'eibd'.

Related lectures:

\begin{itemize}
 \item 104.271 VO Discrete Mathematics 
 \item 104.272 UE Discrete Mathematics 
 \item 184.189 VU Cryptography 
 \item 182.721 VO Embedded Systems Engineering 
 \item 182.722 LU Embedded Systems Engineering 
 %\item 389.152 VO Network Security 
 \item 389.166 VU Signal Processing 1
 \item 183.624 VU Home and Building Automation 

\end{itemize}

\printbibliography
%\begin{thebibliography}{9}


%\bibitem{eibsec}
%  Granzer, Kastner, Neugschwandtner
%  \emph{\LaTeX:EIBSEC: A Security Extension to KNX}.
%  http://www.knx.org/fileadmin/downloads/05\%20-\%20KNX\%20Partners/03\%20-\%20Becoming\%20a\%20KNX\%20Scientific\%20Partner/2006-11\%20Scientific\%20Conference\%20Papers\%20Vienna/05\_granzer-eibsec\_security-knxsci06-website.pdf
%  2006.

%  \bibitem{knxsec}
%  Salvatore Cavalieri, Giovanni Cutuli
%  \emph{\LaTeX: Introducing Security and Authentication in KNX }.
%  http://www.knx.org/fileadmin/downloads/05\%20-\%20KNX\%20Partners/03\%20-\%20Becoming\%20a\%20KNX\%20Scientific\%20Partner/2008-11\%20Conference/presentations/session2.pdf  
  
    
%    \bibitem{eibd}
%    http://www.auto.tuwien.ac.at/~mkoegler/index.php/bcusdk
    
%\end{thebibliography}
%\bibliography{references}


\end{document}
