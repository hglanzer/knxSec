\section{KNX security concept}

In the early days of \gls{hba}, communication security was not considered a critical requirement: firstly, the communication was done over wires,
i.e. physical access to the network was necessary. Secondly, the possible threats by misusing applications like lights- or shutters-switching were considered
negligible. Additionally, the devices used in such networks were characterized by very limited processing power - thus, the comprehensive use of encryption would
have put remarkable computing loads onto these devices and was therefore considered impracticable. 

The basic \gls{knx} standard therefor does \textit{not} specify any security mechanisms for control information:
\\
\textit{"In the case of KNX TP1 or KNX PL110 networks this requires even physical access to the network wires,
which in nearly all cases is impossible as the wires are inside a building or buried underground.
Hence, security aspects are less of a concern for KNX field level media."} \cite{knxSpec}
\\
For \gls{knx}/\gls{ip}, the physical containment arguments do not apply. To counter this, it is proposed to use firewalls and \gls{vpn} to prevent unauthorized access,
as well as hiding critical network parameters from public. The latter concept is also known as \textit{"security by obscurity}, offering - if at all - only 
little protection.

For management communication, a rudimentary, password-based control is used. Therefore, \gls{knx} suffers the following security flaws 
\cite{Granzer05securityin}: for management, the 
used keys are transmitted as cleartext, enabling an attacker to perform a passive attack to obtain the password. Subsequently, the attacker can mount an active
attack, injecting
arbitrary management messages. No methods are foreseen for generation or distribution of the keys.
For control information, an adversary can directly inject arbitrary messages to control the network, allowing passive and active attacks too.
These shortcomings clearly disqualified \gls{knx} for usage in critical environments, restricting its possible field of application.

Today, \gls{hba} systems are used on a large scale, and the available processing power on embedded computing platforms has risen significantly, so the deployment
of such systems would be possible also in critical environments, under the condition that proper security mechanisms are deployed. For \gls{knx}, several extensions
exist which will be introduced in the next sections.

\subsection{KNX Data Security}

In 2013, the KNX association published "Application Note 158" \cite{knx_data_sec} which specifies the \gls{knx} \gls{s-al}, providing
authentication and encryption, and the \gls{ail}, implementing access control, booth being part of the application layer.
The settlement of these functions above the transport layer allows a transparent, communication media independent end-to-end encryption.

The application layer service code 0xF31 is reserved for this purpose, indicating that a secure header and a \gls{s-al} \gls{pdu} 
follow instead of a plaintext-\gls{pdu}. This allows the usage of the secure services just in situations where they are needed - otherwise, the plaintext application
layer services can be used.

The \gls{s-al} services defines modes for authenticated encryption or authentication-only of a higher-level cleartext \gls{apdu}. As underlying block cipher
\gls{aes}128 is used in \gls{ccm} mode, encrypting the payload with \gls{ctr} and providing integrity with \gls{cbc} mode. The overhead introduced by the 
\gls{mac2}is reduced by 
using only the 32 most significant bits instead of the whole 128 bit block obtained from \gls{cbc}. Source- and destination address as well as
frame- and addresstype, the \gls{tpci}, length information and a 6 byte sequence number determine the \gls{iv} for the \gls{cbc} algorithm.
The sequence number is a simple counter value that provides data freshness, thus preventing replay attacks, and is sent along with every \gls{s-al} \gls{pdu}.
For synchronization of this sequence number between two devices, a \gls{s-al} Sync-service is defined. Because no sequence number can be used here to guarantee
data freshness, a challenge-response mechanism is used instead.
Two different types of keys are used: a \gls{fdsk} is used for initial setup with the \gls{ets}. The \gls{ets} then generates the \gls{tk}, which is used by the
device for securing of the outgoing messages. Consequently, every device must know the \gls{tk} of it's communication partners.

While the \gls{s-al} empowers two devices to communicate in a secure way, the \gls{ail} allows a fine-grained control which sender has access to which
data objects. Therefore, every \textit{link} (a combination of source address and data or service object) is connected with a \textit{role}, which in turn
has some specific \textit{permissions}. 

\subsection{EIBsec}

EIBsec is another extension to \gls{knx}, allowing its deployment in security-critical environments by using special key servers, responsible for dedicated sets
of keys. EIBsec divides a \gls{knx} network into subnets, connected by devices called \gls{acu}. Beside their native task, i.e. routing traffic, they
 are responsible for the key management of their network segments, which includes key generation, distribution and revocation. Every standard device that
 wishes to communicate with other devices must at first retrieve the corresponding secret key from its responsible \gls{acu}, which can therefor control the
 group membership of the requesting device by allowing or denying the request respectively by revoking the key.

EIBsec uses two different keys: in normal mode, a session with the keyserver is established to retrieve the session key. This mode uses encryption-only, integrity
must therefor be 

\subsection{KNX IP Security}
